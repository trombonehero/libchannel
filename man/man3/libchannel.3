.TH "libchannel" 3 "Sat Sep 1 2012" "libchannel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libchannel \- 
.PP
libchannel provides an abstraction around communication channels like sockets\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBchannel\fP"
.br
.RI "\fI[opaque] A communications channel for sending data and capabilities (eg file descriptors and channels)\&. \fP"
.ti -1c
.RI "struct \fBmessage\fP"
.br
.RI "\fI[opaque] A message that can be sent over a \fBchannel\fP\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBchannel\fP * \fBchannel_wrap_socket\fP (int sock)"
.br
.RI "\fICreate a \fBchannel\fP that wraps a UNIX domain socket\&. \fP"
.ti -1c
.RI "bool \fBchannel_isvalid\fP (struct \fBchannel\fP *)"
.br
.RI "\fITests the validity of a pointer that claims to be a \fBchannel\fP\&. \fP"
.ti -1c
.RI "void \fBchannel_destroy\fP (struct \fBchannel\fP *c)"
.br
.RI "\fIFree a \fBchannel\fP\&. \fP"
.ti -1c
.RI "int \fBchannel_send\fP (struct \fBchannel\fP *, struct \fBmessage\fP *)"
.br
.RI "\fISend data and/or capabilities over a channel\&. \fP"
.ti -1c
.RI "void \fBchannel_init\fP (\fBchannel\fP *, int magic, int(*size)(struct \fBchannel\fP *), int(*copy)(struct \fBchannel\fP *, void *dest), int(*send)(struct \fBchannel\fP *, struct \fBmessage\fP *))"
.br
.RI "\fIInitialize a channel\&. \fP"
.ti -1c
.RI "int \fBchannel_size\fP (\fBchannel\fP *)"
.br
.RI "\fIHow many bytes does a particular \fBchannel\fP take to store? \fP"
.in -1c
.SH "Detailed Description"
.PP 
libchannel provides an abstraction around communication channels like sockets\&. 

This allows a message-passing style of interaction, whether the backend is a socket or a function call in the same address space\&. 
.SH "Function Documentation"
.PP 
.SS "void channel_destroy (struct \fBchannel\fP *c)"

.PP
Free a \fBchannel\fP\&. \fBParameters:\fP
.RS 4
\fIc\fP must be a channel or NULL 
.RE
.PP

.PP
Definition at line 99 of file libchannel\&.c\&.
.PP
References channel_isvalid()\&.
.PP
.nf
{
        assert(channel_isvalid(c));
        free(c);
}
.fi
.SS "void channel_init (\fBchannel\fP *, intmagic, int(*)(struct \fBchannel\fP *)size, int(*)(struct \fBchannel\fP *, void *dest)copy, int(*)(struct \fBchannel\fP *, struct \fBmessage\fP *)send)"

.PP
Initialize a channel\&. \fBParameters:\fP
.RS 4
\fImagic\fP implementation-specific magic value 
.br
\fIsize\fP function: get total size of channel struct 
.br
\fIcopy\fP function: copy channel to somewhere in memory 
.br
\fIsend\fP function: send a message over the channel
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error 
.RE
.PP

.SS "struct \fBchannel\fP* channel_wrap_socket (intsock)\fC [read]\fP"

.PP
Create a \fBchannel\fP that wraps a UNIX domain socket\&. \fBParameters:\fP
.RS 4
\fIsock\fP A UNIX domain socket\&. This must be a UDS, rather than e\&.g\&. a TCP connection, at least until we figure out how to gracefully degrade when we can't send file descriptors and other channels\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
NULL on error 
.RE
.PP

.PP
Definition at line 79 of file libchannel\&.c\&.
.PP
.nf
{
        return uds_wrap(uds_create(sock));
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for libchannel from the source code\&.
